# RFC001: Strategy Evaluation & Validation System - Technical Design

## Document Context
This RFC defines the technical architecture for the Strategy Evaluation & Validation System based on the requirements established in PRD001.md. It translates the product vision into concrete technical decisions, component interactions, and implementation approaches.

## Overview

The Strategy Evaluation & Validation System implements a **stateless, web-first architecture** with optional lightweight memory capabilities. The system consists of four core components orchestrated through a simple linear workflow, designed to generate and validate healthcare access strategies in under 30 seconds.

**Core Architecture Pattern**: MCP → Strategy Generation → Regulatory Validation → Memory Storage
**Integration Approach**: Minimal external dependencies, web-API driven, graceful degradation

## Architecture

### System Components

**Core Architecture Pattern**: LangGraph orchestration with sequential component execution (1 tool + 3 agents)
**Integration Approach**: Minimal external dependencies, web-API driven, graceful degradation
**Architecture Consistency**: Follows established patterns from `agents/patient_navigator/information_retrieval/` and `agents/tooling/rag/`

### Data Flow

1. **Input Processing**: Plan constraints (copay, deductible, network) → StrategyMCP Tool (`agents/tooling/mcp/strategy/`)
2. **Context Assembly**: StrategyMCP queries Plan Metadata Table, Web Search APIs, and Vector Store → organized context
3. **Strategy Generation**: StrategyCreator Agent (`agents/patient_navigator/strategy/creator/`) receives organized context → 3+ strategy candidates via multi-objective optimization
4. **Validation Pipeline**: RegulatoryAgent (`agents/patient_navigator/strategy/regulatory/`) validates strategies against Regulatory DB + live web → compliance assessment
5. **Storage Initiation**: StrategyMemoryLite Agent (`agents/patient_navigator/strategy/memory/`) persists validated strategies → vector store + metadata table persistence

### Component Specifications

#### 1. StrategyMCP (Model Context Protocol)

**Technical Role**: Plan metadata processor and context coordinator
**Input Interface**: JSON object with plan constraints
**Output Interface**: Structured context object for strategy generation

```typescript
interface PlanConstraints {
  copay: number;
  deductible: number;
  networkProviders: string[];
  geographicScope: string;
  specialtyAccess: string[];
}

interface ContextRetrievalResult {
  webSearchResults: SearchResult[];
  relevantStrategies: MemoryStrategy[];
  queryMetadata: QueryMetadata;
}
```

**Implementation Approach**:
- **Tool Architecture**: Implement as StrategyMCPTool class following `agents/tooling/rag/core.py` pattern
- **Query Generation**: Process plan constraints into 3+ distinct web search queries
- **RAG Integration**: Semantic retrieval from StrategyMemoryLite vector store using established database patterns
- **Fallback Handling**: Default to web-only search if memory retrieval fails
- **Caching Strategy**: 5-minute TTL for web search results to handle concurrent requests

#### 2. StrategyCreator Agent

**Technical Role**: Multi-objective optimization engine for healthcare strategies with integrated LLM scoring
**Input Interface**: Context from StrategyMCP + user priority selection
**Output Interface**: Structured strategy recommendations with rationale + LLM-generated optimization scores

```typescript
interface StrategyRequest {
  context: ContextRetrievalResult;
  optimizationPriority: 'speed' | 'cost' | 'quality';
  userPreferences?: Partial<UserPreferences>;
}

interface StrategyResponse {
  strategies: Strategy[];
  generationMetadata: GenerationMetadata;
}

interface Strategy {
  id: string;
  title: string;
  approach: string;
  rationale: string;
  // LLM-Generated Optimization Scores (0.0-1.0)
  llmOptimizationScore: {
    speed: number;     // How quickly this strategy can be executed
    cost: number;      // Cost-effectiveness of this approach  
    quality: number;   // Expected quality of care/outcomes
  };
  llmConfidenceScore: number; // LLM confidence in strategy effectiveness
  actionableSteps: string[];
}
```

**Implementation Approach**:
- **Agent Architecture**: Inherit from BaseAgent following `agents/patient_navigator/information_retrieval/agent.py` pattern
- **Multi-Objective Algorithm**: Weighted scoring based on user priority selection
- **Integrated LLM Scoring**: Each generated strategy includes self-assessment scores for optimization dimensions
- **Template System**: Structured strategy format using prompts/ directory with scoring integration
- **Reasoning Chain**: Explicit rationale linking context to recommendations and score justification
- **Diversity Mechanism**: Ensure strategies explore different approaches (in-network vs out-of-network, preventive vs reactive)
- **Score Calibration**: LLM scores calibrated to match expected performance characteristics

#### 3. RegulatoryAgent (ReAct Pattern)

**Technical Role**: Compliance validation engine with hybrid data sources + storage initiation
**Input Interface**: Strategy objects from StrategyCreator
**Output Interface**: Validation results with compliance reasoning + storage trigger

```typescript
interface ValidationRequest {
  strategies: Strategy[];
  regulatoryContext: RegulatoryContext;
}

interface ValidationResult {
  strategyId: string;
  complianceStatus: 'approved' | 'flagged' | 'rejected';
  validationReasons: ValidationReason[];
  confidenceScore: number;
  sourceReferences: SourceReference[];
}

interface ValidationReason {
  category: 'legal' | 'feasibility' | 'ethical';
  description: string;
  severity: 'info' | 'warning' | 'critical';
}
```

**Implementation Approach**:
- **Agent Architecture**: Inherit from BaseAgent following `agents/patient_navigator/information_retrieval/agent.py` pattern
- **ReAct Pattern**: Reason → Act → Observe cycle for validation logic
- **Dual Source Strategy**: RAG database for baseline rules + live web for recent updates following established RAG integration patterns
- **Confidence Scoring**: Weighted validation based on source authority and recency
- **Storage Trigger**: Initiate StrategyMemoryLite storage process for validated strategies
- **Audit Trail**: Complete logging of validation decisions for compliance review

#### 4. StrategyMemoryLite

**Technical Role**: Lightweight persistent storage handler for strategy reuse via direct database operations
**Input Interface**: Storage requests from RegulatoryAgent with validated strategies and metadata
**Output Interface**: Semantic retrieval results for StrategyMCP queries + storage confirmation

```typescript
// MVP Schema Interfaces
interface StrategyRecord {
  id: string;
  title: string;
  category: string;
  markdown: string;
  authorId?: string;
  
  // LLM-Generated Scores (from StrategyCreator)
  llmScoreSpeed: number;    // 0.0-1.0
  llmScoreCost: number;     // 0.0-1.0
  llmScoreQuality: number;  // 0.0-1.0
  llmConfidenceScore: number; // 0.0-1.0
  
  // Human Effectiveness Scores (from user feedback)
  humanEffectivenessAvg?: number;     // 1.0-5.0
  humanFollowabilityAvg?: number;     // 1.0-5.0
  humanOutcomeSuccessRate?: number;   // 0.0-1.0
  numHumanRatings: number;
  
  feedbackSummary?: string;
  createdAt: Date;
  updatedAt: Date;
}

interface StrategyVector {
  strategyId: string;
  embedding: number[];
  modelVersion: string;
  createdAt: Date;
}
```

**Implementation Approach**:
- **MVP Schema**: 2-table design with clean separation of concerns
  - `strategies.strategies`: Core metadata with dual scoring (LLM + human)
  - `strategies.strategy_vectors`: Embeddings with model versioning
- **Agent Architecture**: Inherit from BaseAgent following established patterns  
- **Direct Supabase Integration**: Use Supabase SDK following existing database connection patterns
- **Dual Scoring System**: 
  - **LLM Scores**: StrategyCreator generates speed/cost/quality scores during creation
  - **Human Scores**: User feedback updates effectiveness and outcome metrics
- **Vector Operations**: JOIN queries combining metadata with similarity search
- **Performance Optimization**: Indexes following established pgvector patterns

## Technical Decisions

### 1. LangGraph Orchestration Architecture
**Decision**: LangGraph workflow orchestration with lightweight memory
**Rationale**: 
- Clear node-based separation of concerns for each component
- Built-in error handling and retry mechanisms
- Visual workflow representation aids debugging and maintenance
- Enables conditional flows (e.g., skip memory query if vector store unavailable)
- Simplifies testing with individual node isolation
- **Maintains horizontal scaling**: Stateless workflow design enables multiple instances across containers/servers

### 2. Web Search Integration
**Decision**: Direct API integration with fallback providers
**Rationale**:
- Real-time data access for current provider information
- Multiple provider fallback (Google → Bing → DuckDuckGo)
- Circuit breaker pattern prevents cascading failures
- 5-second timeout with graceful degradation

### 3. Validation Data Sources
**Decision**: Hybrid RAG + live web validation approach with direct database access
**Rationale**:
- RAG provides consistent baseline regulatory knowledge via direct Supabase queries
- Live web captures recent regulatory changes
- Confidence scoring balances accuracy with recency
- Audit trail stored directly in Supabase tables for compliance requirements
- Direct SDK calls eliminate Edge Function latency and complexity

### 4. MVP Database Architecture
**Decision**: Clean 2-table approach with dual scoring system (LLM + human feedback)
**Rationale**:
- **Simplified Schema**: `strategies.strategies` (metadata) + `strategies.strategy_vectors` (embeddings) vs complex multi-table design
- **Performance Separation**: Vector operations isolated from metadata queries for optimal performance
- **Dual Scoring System**: LLM-generated scores from StrategyCreator + human effectiveness scores from user feedback
- **Established Patterns**: Follows existing `documents.*` schema conventions and pgvector usage
- **MVP Ready**: Supports all core requirements with minimal complexity
- **Easy Extension**: Embedded scoring fields avoid complex joins while supporting future enhancements

## Alternative Approaches Considered

### Alternative 1: Simple Linear Pipeline
**Approach**: Direct function calls between components without orchestration framework
**Rejected Because**: 
- Lacks built-in error handling and retry mechanisms
- Difficult to implement conditional flows (e.g., memory query failures)
- No visual representation of workflow for debugging
- Testing individual components becomes more complex

### Alternative 2: Complex Multi-Table Strategy Storage
**Approach**: Separate tables for strategies, validation records, scoring, usage analytics, etc.
**Rejected Because**:
- Over-engineering for MVP requirements (8+ tables vs 2 tables)
- Performance impact from complex JOINs for common queries
- Higher implementation complexity without proportional benefits
- Embedded scoring fields provide same functionality with better performance

### Alternative 3: Synchronous Validation Pipeline
**Approach**: Sequential validation of each strategy
**Rejected Because**:
- Performance impact for multiple strategies
- Parallel validation reduces total response time
- Async approach better utilizes external API rate limits

## Database Implementation

### MVP Schema Migration
**File**: `supabase/migrations/20250129000000_create_strategy_tables.sql`

```sql
-- Create strategies schema
CREATE SCHEMA IF NOT EXISTS strategies;

-- Core strategy metadata with dual scoring
CREATE TABLE strategies.strategies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  category TEXT NOT NULL,
  markdown TEXT NOT NULL,
  author_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- LLM-Generated Scores (from StrategyCreator)
  llm_score_speed NUMERIC(3,2) CHECK (llm_score_speed >= 0.0 AND llm_score_speed <= 1.0),
  llm_score_cost NUMERIC(3,2) CHECK (llm_score_cost >= 0.0 AND llm_score_cost <= 1.0),
  llm_score_quality NUMERIC(3,2) CHECK (llm_score_quality >= 0.0 AND llm_score_quality <= 1.0),
  llm_confidence_score NUMERIC(3,2) CHECK (llm_confidence_score >= 0.0 AND llm_confidence_score <= 1.0),
  
  -- Human Effectiveness Scores (from user feedback)
  human_effectiveness_avg NUMERIC(3,2) CHECK (human_effectiveness_avg >= 1.0 AND human_effectiveness_avg <= 5.0),
  human_followability_avg NUMERIC(3,2) CHECK (human_followability_avg >= 1.0 AND human_followability_avg <= 5.0),
  human_outcome_success_rate NUMERIC(3,2) CHECK (human_outcome_success_rate >= 0.0 AND human_outcome_success_rate <= 1.0),
  num_human_ratings INTEGER DEFAULT 0,
  
  feedback_summary TEXT
);

-- Vector embeddings with model versioning
CREATE TABLE strategies.strategy_vectors (
  strategy_id UUID PRIMARY KEY REFERENCES strategies.strategies(id) ON DELETE CASCADE,
  embedding VECTOR(1536), -- Following existing pgvector pattern
  model_version TEXT NOT NULL DEFAULT 'text-embedding-3-small',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Performance indexes
CREATE INDEX idx_strategies_category ON strategies.strategies (category);
CREATE INDEX idx_strategies_llm_scores ON strategies.strategies (llm_score_speed, llm_score_cost, llm_score_quality);
CREATE INDEX idx_strategies_human_scores ON strategies.strategies (human_effectiveness_avg, human_outcome_success_rate);
CREATE INDEX idx_strategy_vectors_embedding ON strategies.strategy_vectors 
  USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- RLS and permissions following established patterns
ALTER TABLE strategies.strategies ENABLE ROW LEVEL SECURITY;
ALTER TABLE strategies.strategy_vectors ENABLE ROW LEVEL SECURITY;
GRANT USAGE ON SCHEMA strategies TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA strategies TO postgres, service_role;
GRANT SELECT ON ALL TABLES IN SCHEMA strategies TO authenticated;
```

## Implementation Plan

### Phase 1: MVP Database + Core Components (Weeks 1-2)
- **Database Migration**: Create MVP 2-table schema with dual scoring
- **LangGraph Setup**: Workflow orchestration framework configuration
- **StrategyMCP Tool**: Plan metadata integration + web query generation
- **StrategyCreator Agent**: Multi-objective optimization with integrated LLM scoring
- **Integration Testing**: End-to-end LangGraph workflow with MVP database

### Phase 2: Validation & Memory Integration (Weeks 3-4)
- **RegulatoryAgent**: RAG integration + ReAct validation logic
- **StrategyMemoryLite Agent**: MVP 2-table storage with dual scoring support
- **LangGraph Flow**: Complete workflow with conditional memory queries and storage triggers
- **Human Feedback System**: User feedback collection and scoring updates

### Phase 3: Production Readiness (Weeks 5-6)
- **Circuit Breakers**: External service failure handling integrated into LangGraph nodes
- **Caching Layer**: Web search result caching within StrategyMCP node
- **Essential Monitoring**: Request tracking and error logging for LangGraph workflow
- **Security Review**: Data encryption and access controls
- **Documentation**: API documentation and deployment guides focused on coding agent implementation

## Risk Assessment

### High Risk: External Service Dependencies
**Risk**: Web search APIs and regulatory databases become unavailable
**Mitigation**: 
- Multiple provider fallback chain
- Circuit breaker pattern with exponential backoff
- Cached fallback strategies for common scenarios
- Graceful degradation messaging to users

### Medium Risk: Vector Store Performance
**Risk**: Semantic search latency impacts response time
**Mitigation**:
- Indexing optimization for common constraint patterns
- Constraint-based pre-filtering before vector search
- Async background indexing for new strategies
- Performance monitoring with alerting thresholds

### Medium Risk: Validation Accuracy
**Risk**: False positives/negatives in regulatory compliance
**Mitigation**:
- Confidence scoring with human review thresholds
- Multiple source validation for high-stakes strategies
- Audit trail for compliance review
- Manual override capability for validation results

## Testing Strategy

### Component Testing
- **MCP Component Testing**: Plan metadata processing, web query generation, and RAG retrieval functionality tested independently
- **Agent Testing**: StrategyCreator and RegulatoryAgent tested as standalone components with mock inputs
- **Database Operations Testing**: Vector store and metadata table operations via direct Supabase SDK calls
- **Schema Validation**: Input/output interface validation for each component
- **Error Handling**: Component failure and recovery scenario testing

### Integration Testing
- **End-to-End LangGraph Workflow**: Complete strategy generation pipeline execution
- **External Service Integration**: Real API testing in staging environment
- **Memory Integration**: Vector store and metadata table operations testing

### Human Validation Testing
- **Regulatory Accuracy Review**: Manual validation of compliance decisions with healthcare experts
- **Strategy Quality Assessment**: Stakeholder review of generated strategy relevance and actionability  
- **User Acceptance Testing**: Healthcare consumer feedback on strategy clarity and usefulness
- **Compliance Audit**: Legal review of regulatory validation logic and audit trails

## Performance Considerations

### Response Time Optimization
- **Parallel Processing**: Concurrent web searches and validation
- **Connection Pooling**: Reuse HTTP connections for external APIs
- **Query Optimization**: Pre-filter memory searches by constraints
- **Caching Strategy**: 5-minute TTL for web search results

### Scalability Planning (MVP Architecture Benefits)
- **Horizontal Scaling**: Stateless LangGraph workflows enable multiple instances across containers
- **Database Efficiency**: 2-table design reduces JOIN complexity and improves concurrent access
- **Index Optimization**: Separate indexes for metadata queries and vector similarity search
- **Dual Scoring Performance**: Embedded scoring fields eliminate complex aggregation queries
- **Rate Limit Management**: Distributed rate limiting for external APIs across workflow instances

### Memory Management (MVP 2-Table Benefits)
- **Clean Separation**: Vector operations isolated from metadata queries for optimal performance
- **Storage Efficiency**: ~10MB per 1000 strategies with embedded scoring vs complex table JOINs
- **Query Performance**: Metadata queries avoid vector table access, vector searches avoid metadata overhead
- **Cache Management**: LRU eviction for web search result cache
- **Database Connections**: Connection pooling optimized for both table types
- **Garbage Collection**: Regular cleanup of expired cached data

## Next Steps

This RFC establishes the technical foundation for the Strategy Evaluation & Validation System. The next document (TODO001.md) will break down the implementation into specific, actionable development tasks with timelines and dependencies.

**Immediate Actions**:
1. Technical review and approval of architecture decisions
2. Development environment setup and dependency installation
3. Implementation task breakdown (TODO001.md creation)
4. Development timeline and resource allocation