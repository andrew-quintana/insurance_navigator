#!/usr/bin/env node

/**
 * Environment Synchronization Script
 * 
 * This script synchronizes environment variables across different platforms
 * (Render, Vercel, Supabase) to ensure consistency between environments.
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';

interface SyncOptions {
  source: 'development' | 'production';
  target: 'render' | 'vercel' | 'supabase' | 'all';
  dryRun?: boolean;
  verbose?: boolean;
}

interface EnvironmentVariable {
  name: string;
  value: string;
  description?: string;
  required: boolean;
  platform: string[];
}

class EnvironmentSyncer {
  private options: SyncOptions;
  private envVars: EnvironmentVariable[] = [];

  constructor(options: SyncOptions) {
    this.options = {
      dryRun: false,
      verbose: false,
      ...options
    };
  }

  /**
   * Loads environment variables from .env files
   */
  private loadEnvironmentVariables(): void {
    const envFile = `.env.${this.options.source}`;
    
    if (!existsSync(envFile)) {
      throw new Error(`Environment file not found: ${envFile}`);
    }

    const content = readFileSync(envFile, 'utf8');
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      
      // Skip comments and empty lines
      if (!trimmed || trimmed.startsWith('#')) {
        continue;
      }

      const [name, ...valueParts] = trimmed.split('=');
      const value = valueParts.join('=');

      if (name && value) {
        this.envVars.push({
          name: name.trim(),
          value: value.trim(),
          required: this.isRequiredVariable(name),
          platform: this.getPlatformsForVariable(name)
        });
      }
    }
  }

  /**
   * Determines if a variable is required
   */
  private isRequiredVariable(name: string): boolean {
    const requiredVars = [
      'SUPABASE_URL',
      'SUPABASE_ANON_KEY',
      'SUPABASE_SERVICE_ROLE_KEY',
      'DATABASE_URL',
      'NEXT_PUBLIC_API_BASE_URL',
      'NEXT_PUBLIC_APP_URL'
    ];

    return requiredVars.includes(name);
  }

  /**
   * Determines which platforms a variable should be synced to
   */
  private getPlatformsForVariable(name: string): string[] {
    const platforms: string[] = [];

    // Backend variables (Render)
    if (name.startsWith('SUPABASE_') || 
        name.startsWith('DATABASE_') ||
        name.includes('API_KEY') ||
        name.includes('SECRET') ||
        name.includes('ENCRYPTION')) {
      platforms.push('render');
    }

    // Frontend variables (Vercel)
    if (name.startsWith('NEXT_PUBLIC_')) {
      platforms.push('vercel');
    }

    // Database variables (Supabase)
    if (name.startsWith('SUPABASE_') || name.startsWith('DATABASE_')) {
      platforms.push('supabase');
    }

    return platforms;
  }

  /**
   * Generates Render environment variables configuration
   */
  private generateRenderConfig(): string {
    const renderVars = this.envVars.filter(v => v.platform.includes('render'));
    
    let config = '# Render Environment Variables\n';
    config += '# Generated by sync-environments script\n\n';

    for (const envVar of renderVars) {
      config += `${envVar.name}=${envVar.value}\n`;
    }

    return config;
  }

  /**
   * Generates Vercel environment variables configuration
   */
  private generateVercelConfig(): string {
    const vercelVars = this.envVars.filter(v => v.platform.includes('vercel'));
    
    let config = '# Vercel Environment Variables\n';
    config += '# Generated by sync-environments script\n\n';

    for (const envVar of vercelVars) {
      config += `${envVar.name}=${envVar.value}\n`;
    }

    return config;
  }

  /**
   * Generates Supabase environment variables configuration
   */
  private generateSupabaseConfig(): string {
    const supabaseVars = this.envVars.filter(v => v.platform.includes('supabase'));
    
    let config = '# Supabase Environment Variables\n';
    config += '# Generated by sync-environments script\n\n';

    for (const envVar of supabaseVars) {
      config += `${envVar.name}=${envVar.value}\n`;
    }

    return config;
  }

  /**
   * Writes configuration to file
   */
  private writeConfig(content: string, filename: string): void {
    const filepath = join('config', 'environments', filename);
    
    if (this.options.dryRun) {
      console.log(`[DRY RUN] Would write to ${filepath}:`);
      console.log(content);
    } else {
      writeFileSync(filepath, content);
      console.log(`‚úÖ Written configuration to ${filepath}`);
    }
  }

  /**
   * Synchronizes environment variables
   */
  async sync(): Promise<void> {
    console.log(`üîÑ Synchronizing ${this.options.source} environment to ${this.options.target}...\n`);

    try {
      this.loadEnvironmentVariables();

      if (this.options.verbose) {
        console.log(`üìã Loaded ${this.envVars.length} environment variables\n`);
      }

      switch (this.options.target) {
        case 'render':
          this.writeConfig(this.generateRenderConfig(), 'render.env');
          break;
        case 'vercel':
          this.writeConfig(this.generateVercelConfig(), 'vercel.env');
          break;
        case 'supabase':
          this.writeConfig(this.generateSupabaseConfig(), 'supabase.env');
          break;
        case 'all':
          this.writeConfig(this.generateRenderConfig(), 'render.env');
          this.writeConfig(this.generateVercelConfig(), 'vercel.env');
          this.writeConfig(this.generateSupabaseConfig(), 'supabase.env');
          break;
        default:
          throw new Error(`Unknown target platform: ${this.options.target}`);
      }

      console.log('\n‚úÖ Environment synchronization completed successfully!');

      if (this.options.verbose) {
        this.printSummary();
      }

    } catch (error) {
      console.error('‚ùå Synchronization failed:', error);
      throw error;
    }
  }

  /**
   * Prints synchronization summary
   */
  private printSummary(): void {
    console.log('\nüìä Synchronization Summary:');
    console.log(`  Source Environment: ${this.options.source}`);
    console.log(`  Target Platform: ${this.options.target}`);
    console.log(`  Variables Processed: ${this.envVars.length}`);
    
    const platformCounts = this.envVars.reduce((acc, envVar) => {
      envVar.platform.forEach(platform => {
        acc[platform] = (acc[platform] || 0) + 1;
      });
      return acc;
    }, {} as Record<string, number>);

    console.log('  Platform Distribution:');
    Object.entries(platformCounts).forEach(([platform, count]) => {
      console.log(`    ${platform}: ${count} variables`);
    });
  }
}

/**
 * Main execution function
 */
async function main() {
  const args = process.argv.slice(2);
  const options: SyncOptions = {
    source: 'development',
    target: 'all'
  };

  // Parse command line arguments
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--source':
      case '-s':
        options.source = args[++i] as 'development' | 'production';
        break;
      case '--target':
      case '-t':
        options.target = args[++i] as 'render' | 'vercel' | 'supabase' | 'all';
        break;
      case '--dry-run':
      case '-d':
        options.dryRun = true;
        break;
      case '--verbose':
      case '-v':
        options.verbose = true;
        break;
      case '--help':
      case '-h':
        console.log(`
Environment Synchronization Tool

Usage: npm run sync:environments [options]

Options:
  -s, --source <env>      Source environment (development|production)
  -t, --target <platform> Target platform (render|vercel|supabase|all)
  -d, --dry-run          Show what would be done without making changes
  -v, --verbose          Enable verbose output
  -h, --help             Show this help message

Examples:
  npm run sync:environments
  npm run sync:environments -- --source production --target render
  npm run sync:environments -- --dry-run --verbose
        `);
        process.exit(0);
        break;
    }
  }

  const syncer = new EnvironmentSyncer(options);
  await syncer.sync();
}

// Run if called directly
if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå Synchronization script failed:', error);
    process.exit(1);
  });
}

export { EnvironmentSyncer };